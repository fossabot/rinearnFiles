coding UTF-8;

# PRAGMA COMPILE    REFERRAL
# PRAGMA RESERVE    ALL
# 
# PRAGMA INTERNAL   RINEARN  {
#     
#     MAINSTREAM    { "R4***",    "OR_LATER" }
#     COMPATIBLE    { "R3***",    "R2***"    }
#     
#     SYSTEMCALL    { "SYSTEM_PROCESS_DRIVER_TEXT_*" }
#     INTERFACE     { "GPCI",     "DPCI" }
#     
#     CONNECT       { "ONLOAD",   "STATIC",   "rxvesapi.process.driver.TextProcessDriver"   }
#     ARCHIVE       { "ONBUILD",  "STATIC",   "rxvesapi.process.library.TextProcessLibrary" }
#     
# }
# 
# PRAGMA INTERNAL   END
# PRAGMA END

/**
 * <p>
 * VCSSL Text ライブラリ は、テキスト（文字列）処理を扱う標準ライブラリです。
 * </p>
 * 
 * <p>
 * このライブラリでは、文字列を扱う string 型の変数に対して、
 * 長さや部分文字列の取得、検索と置換、分割などの機能を提供します。
 * なお、検索、置換、分割では、正規表現を用いる事もできます。
 * </p>
 * 
 * @author  松井文宏 - Fumihiro Matsui ( RINEARN )
 * @license Public domain ( CC0 )
 */


import System;

/** 文字列と一致する、全ての部分を探す検索モードです。 */
public const int ALL = 101;

/** 正規表現と一致する、全ての部分を探す検索モードです。 */
public const int ALL_PATTERN = 102;

/** 文字列と一致する、最初の部分を探す検索モードです。 */
public const int FIRST = 201;

/** 正規表現と一致する、最初の部分を探す検索モードです。 */
public const int FIRST_PATTERN = 202;

/** 文字列と一致する、最後の部分を探す検索モードです。 */
public const int LAST = 301;

/** 正規表現と一致する、最後の部分を探す検索モードです。 */
public const int LAST_PATTERN = 302;


/** 文字列の先頭が、部分文字列と一致するかを判断する判定モードです。 */
public const int START = 10001;

/** 文字列の先頭が、正規表現と一致するかを判断する判定モードです。 */
public const int START_PATTERN = 10002;

/** 文字列の終端が、部分文字列と一致するかを判断する判定モードです。 */
public const int END = 10003;

/** 文字列の終端が、正規表現と一致するかを判断する判定モードです。 */
public const int END_PATTERN = 10004;

/** 文字列のどこかに、部分文字列と一致する部分が存在するかを判断する判定モードです。 */
public const int CONTAIN = 10005;

/** 文字列のどこかに、正規表現と一致する部分が存在するかを判断する判定モードです。 */
public const int CONTAIN_PATTERN = 10006;

/** 文字列の全体が、正規表現と一致するかを判断する判定モードです。 */
public const int FULL_PATTERN = 10007;


/** エラーメッセージ、不明な検索モードが指定された場合 */
private const string ERROR_UNKNOWN_MODE = "指定されたモードは、この関数では未対応です：";


private string toConstName(int mode) {
	if (mode == ALL) {
		return "FIRST";
	} else if (mode == ALL_PATTERN) {
		return "FIRST_PATTERN";
	} else if (mode == LAST) {
		return "LAST";
	} else if (mode == LAST_PATTERN) {
		return "LAST_PATTERN";
	} else if (mode == ALL) {
		return "ALL";
	} else if (mode == ALL_PATTERN) {
		return "ALL_PATTERN";
	} else if (mode == START) {
		return "START";
	} else if (mode == START_PATTERN) {
		return "START_PATTERN";
	} else if (mode == END) {
		return "END";
	} else if (mode == END_PATTERN) {
		return "END_PATTERN";
	} else if (mode == CONTAIN) {
		return "CONTAIN";
	} else if (mode == CONTAIN_PATTERN) {
		return "CONTAIN_PATTERN";
	} else if (mode == FULL_PATTERN) {
		return "FULL_PATTERN";
	} else {
		return mode;
	}
}




/**
 * 文字列内の、指定されたインデックスの位置にある文字を、1文字のstring型変数として返します。
 *
 * @param text 対象の文字列
 * @param index 文字の位置インデックス
 * @return 文字
 */
string atText( string text, int index ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getCharacter( text, index );
}


/**
 * 文字列の先頭、末尾、または全体が、指定された文字列か正規表現に一致するかを判定します。
 * 
 * @param text 対象のテキスト
 * @param query 一致を判定する部分文字列
 * @param mode 判定モード（ <a href="#START">START</a>, <a href="#END">END</a>, <a href="#CONTAIN">CONTAIN</a>, <a href="#START_PATTERN">START_PATTERN</a>, <a href="#END_PATTERN">END_PATTERN</a>, <a href="#CONTAIN_PATTERN">CONTAIN_PATTERN</a>, <a href="#FULL_PATTERN">FULL_PATTERN</a> ）
 * @return 判定結果（ 一致すれば true ）
 */
public bool checkText( string text, string query, int mode ) {
	
	if (mode == START) {
		
		return SYSTEM_PROCESS_DRIVER_TEXT_startsWith( text, query );
		
	} else if (mode == END) {
		
		return SYSTEM_PROCESS_DRIVER_TEXT_endsWith( text, query );
		
	} else if (mode == CONTAIN) {
		
		int index[] = findText(text, query, FIRST);
		
		if (length(index, 0) == 0) {
			return false;
			
		} else if (0 <= index[0]) {
			return true;
			
		} else {
			return false;
		}
		
	} else if (mode == START_PATTERN) {
		
		int index[] = findText(text, query, FIRST_PATTERN);
		
		if (length(index, 0) == 0) {
			return false;
			
		} else if (index[0] == 0) {
			return true;
			
		} else {
			return false;
		}
		
	} else if (mode == END_PATTERN) {
		
		int textLength = countText(text);
		int index[] = findText(text, query, LAST_PATTERN);
		string ext[] = extractText(text, query, LAST_PATTERN);
		
		if (length(index, 0) == 0) {
			return false;
			
		} else if (index[0] == textLength - countText(ext[0])) {
			return true;
			
		} else {
			return false;
		}
		
	} else if (mode == CONTAIN_PATTERN) {
		
		int index[] = findText(text, query, FIRST_PATTERN);
		
		if (length(index, 0) == 0) {
			return false;
			
		} else if (0 <= index[0]) {
			return true;
			
		} else {
			return false;
		}
		
	} else if (mode == FULL_PATTERN) {
		
		return SYSTEM_PROCESS_DRIVER_TEXT_totalMatch( text, query );
		
	} else {
		System.error(ERROR_UNKNOWN_MODE + toConstName(mode));
		return false;
	}
}




/**
 * テキストから、指定された範囲を抜き出したものを返します。
 * <br />
 * 抜き出す範囲は、テキストの各文字に、先頭を 0 としてインデックスを割りふると、cropBegin 番目から cropEnd - 1 番目までの文字列となります。
 * また、文字と文字の「 隙間（すきま） 」にインデックスを割りふると、抜き出す範囲はちょうど cropBegin 番目から cropEnd 番目までの隙間に挟まれた範囲となります。
 * 
 * @param text 対象のテキスト
 * @param cropBegin 抜き出す範囲の開始位置
 * @param cropEnd 抜き出す範囲の終了位置
 * @return 検索一致箇所で分割したテキストの配列
 */
public string cropText( string text, int cropBegin, int cropEnd ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getSubtext( text, cropBegin, cropEnd );
}



/**
 * テキストの文字数をカウントして返します。
 * 
 * @param text 対象のテキスト
 * @return テキストの文字数
 */
public int countText( string text ){
  return SYSTEM_PROCESS_DRIVER_TEXT_countTextLength( text );
}

/**
 * テキストから、部分文字列（ または正規表現 ）に一致する箇所を検索し、その個数をカウントして返します。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索結果の個数
 */
public int countText( string text, string query, int mode ){
	int indices[] = findText(text, query, mode);
	int n = length(indices, 0);
	return n;
}

/**
 * テキストの指定位置以降から、部分文字列（ または正規表現 ）に一致する箇所を検索し、その個数をカウントして返します。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param searchBegin 検索開始位置の文字インデックス
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索結果の個数
 */
public int countText( string text, string query, int searchBegin, int mode ){
	int indices[] = findText(text, query, searchBegin, mode);
	int n = length(indices, 0);
	return n;
}

/**
 * テキストの指定範囲内から、部分文字列（ または正規表現 ）に一致する箇所を検索し、その個数をカウントして返します。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param searchBegin 検索開始位置の文字インデックス
 * @param searchEnd 検索終了位置の文字インデックス + 1 （ <a href="#cropText">cropText</a> 参照 ）
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索結果の個数
 */
public int countText( string text, string query, int searchBegin, int searchEnd, int mode ){
	int indices[] = findText(text, query, searchBegin, searchEnd, mode);
	int n = length(indices, 0);
	return n;
}



/**
 * テキストから、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所の文字インデックスを配列にまとめて返します。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所の文字インデックスを格納する配列
 */
public int[] findText( string text, string query, int mode ) {
	
	if (mode == FIRST) {
		
		int index = SYSTEM_PROCESS_DRIVER_TEXT_getWordIndex(text, query);
		if (0 <= index) {
			int result[] = { index };
			return result;
		} else {
			int result[0];
			return result;
		}
		
	} else if (mode == FIRST_PATTERN) {
		
		int index = SYSTEM_PROCESS_DRIVER_TEXT_getPatternWordIndex(text, query);
		if (0 <= index) {
			int result[] = { index };
			return result;
		} else {
			int result[0];
			return result;
		}
		
	} else if (mode == LAST) {
		
		int index = SYSTEM_PROCESS_DRIVER_TEXT_getLastWordIndex(text, query);
		if (0 <= index) {
			int result[] = { index };
			return result;
		} else {
			int result[0];
			return result;
		}
		
	} else if (mode == LAST_PATTERN) {
		
		int index = SYSTEM_PROCESS_DRIVER_TEXT_getPatternLastWordIndex(text, query);
		if (0 <= index) {
			int result[] = { index };
			return result;
		} else {
			int result[0];
			return result;
		}
		
	} else if (mode == ALL) {
		
		int textIndex = SYSTEM_PROCESS_DRIVER_TEXT_getWordIndex(text, query);
		int arrayIndex = 0;
		int arraySize = 0;
		int result[arraySize];
		
		while (0 <= textIndex) {
			arraySize++;
			alloc[arraySize] result;
			result[ arrayIndex ] = textIndex;
			textIndex = SYSTEM_PROCESS_DRIVER_TEXT_getWordIndex(text, query, textIndex+1);
			arrayIndex++;
		}
		return result;
		
	} else if (mode == ALL_PATTERN) {
		
		int textIndex = SYSTEM_PROCESS_DRIVER_TEXT_getPatternWordIndex(text, query);
		int textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
		int arrayIndex = 0;
		int arraySize = 0;
		int result[arraySize];
		
		while (0 <= textIndex && textIndex < textLength) {
			arraySize++;
			alloc[arraySize] result;
			result[ arrayIndex ] = textIndex;
			textIndex = SYSTEM_PROCESS_DRIVER_TEXT_getPatternWordIndex(text, query, textIndex+1);
			arrayIndex++;
		}
		return result;
		
	} else {
		System.error(ERROR_UNKNOWN_MODE + toConstName(mode));
		int result[0];
		return result;
	}
}

/**
 * テキスト指定位置以降から、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所の文字インデックスを配列にまとめて返します。
 * 検索で一致する箇所が無かった場合、戻り値は要素数 0 の配列となります。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param searchBegin 検索開始位置の文字インデックス
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所の文字インデックスを格納する配列
 */
public int[] findText( string text, string query, int searchBegin, int mode ) {
	int textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
	string croppedText = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, searchBegin, textLength);
	int result[] = findText(croppedText, query, mode);
	result += searchBegin;
	return result;
}

/**
 * テキスト指定範囲内から、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所の文字インデックスを配列にまとめて返します。
 * 検索で一致する箇所が無かった場合、戻り値は要素数 0 の配列となります。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param searchBegin 検索開始位置の文字インデックス
 * @param searchEnd 検索終了位置の文字インデックス + 1 （ <a href="#cropText">cropText</a> 参照 ）
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所の文字インデックスを格納する配列
 */
public int[] findText( string text, string query, int searchBegin, int searchEnd, int mode ) {
	string croppedText = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, searchBegin, searchEnd);
	int result[] = findText(croppedText, query, mode);
	result += searchBegin;
	return result;
}




/**
 * テキストから、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所を抜き出した文字列を配列にまとめて返します。
 * 検索で一致する箇所が無かった場合、戻り値は要素数 0 の配列となります。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所を抜き出した文字列を格納する配列
 */
public string[] extractText( string text, string query, int mode ) {

	if (mode == FIRST) {
		
		int index = SYSTEM_PROCESS_DRIVER_TEXT_getWordIndex(text, query);
		if (0 <= index) {
			string result[] = { query };
			return result;
		} else {
			string result[0];
			return result;
		}
		
	} else if (mode == LAST) {
		
		int index = SYSTEM_PROCESS_DRIVER_TEXT_getLastWordIndex(text, query);
		if (0 <= index) {
			string result[] = { query };
			return result;
		} else {
			string result[0];
			return result;
		}
		
	} else if (mode == FIRST_PATTERN) {
		
		string s = SYSTEM_PROCESS_DRIVER_TEXT_firstMatch(text, query);
		if (s != NULL) {
			string result[] = { s };
			return result;
		} else {
			string result[0];
			return result;
		}
		
	} else if (mode == LAST_PATTERN) {
		
		string s = SYSTEM_PROCESS_DRIVER_TEXT_lastMatch(text, query);
		if (s != NULL) {
			string result[] = { s };
			return result;
		} else {
			string result[0];
			return result;
		}
		
	} else if (mode == ALL) {
		
		int textIndex = SYSTEM_PROCESS_DRIVER_TEXT_getWordIndex(text, query);
		int arrayIndex = 0;
		int arraySize = 0;
		string result[arraySize];
		
		while (0 <= textIndex) {
			arraySize++;
			alloc[arraySize] result;
			result[ arrayIndex ] = query;
			textIndex = SYSTEM_PROCESS_DRIVER_TEXT_getWordIndex(text, query, textIndex+1);
			arrayIndex++;
		}
		return result;
		
	} else if (mode == ALL_PATTERN) {
		
		int textIndex = SYSTEM_PROCESS_DRIVER_TEXT_getPatternWordIndex(text, query);
		int textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
		string textWord = SYSTEM_PROCESS_DRIVER_TEXT_firstMatch(text, query);
		int arrayIndex = 0;
		int arraySize = 0;
		string result[arraySize];
		
		while (0 <= textIndex && textIndex < textLength) {
			arraySize++;
			alloc[arraySize] result;
			result[ arrayIndex ] = textWord;
			textWord = SYSTEM_PROCESS_DRIVER_TEXT_firstMatch(text, query, textIndex+1);
			textIndex = SYSTEM_PROCESS_DRIVER_TEXT_getPatternWordIndex(text, query, textIndex+1);
			arrayIndex++;
		}
		return result;
		
	} else {
		System.error(ERROR_UNKNOWN_MODE + ": " + toConstName(mode));
		int result[0];
		return result;
	}
}

/**
 * テキストの指定位置以降から、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所を抜き出した文字列を配列にまとめて返します。
 * <br />
 * 検索で一致する箇所が無かった場合、戻り値は要素数 0 の配列となります。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param searchBegin 検索開始位置の文字インデックス
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所を抜き出した文字列を格納する配列
 */
public string[] extractText( string text, string query, int searchBegin, int mode ) {
	int textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
	string croppedText = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, searchBegin, textLength);
	string result[] = extractText(croppedText, query, mode);
	return result;
}

/**
 * テキストの指定範囲内から、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所を抜き出した文字列を配列にまとめて返します。
 * <br />
 * 検索で一致する箇所が無かった場合、戻り値は要素数 0 の配列となります。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param searchBegin 検索開始位置の文字インデックス
 * @param searchEnd 検索終了位置の文字インデックス + 1 （ <a href="#cropText">cropText</a> 参照 ）
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所を抜き出した文字列を格納する配列
 */
public string[] extractText( string text, string query, int searchBegin, int searchEnd, int mode ) {
	string croppedText = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, searchBegin, searchEnd);
	string result[] = extractText(croppedText, query, mode);
	return result;
}



/**
 * テキストから、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所を別の文字列で置き換えて返します。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param newPart 検索一致箇所を置き換える文字列
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所を置き換えた文字列
 */
public string replaceText( string text, string query, string newPart, int mode ) {
	if (mode == ALL) {
		return SYSTEM_PROCESS_DRIVER_TEXT_getReplacedText( text, query, newPart );
	
	} else if (mode == ALL_PATTERN) {
		return SYSTEM_PROCESS_DRIVER_TEXT_getPatternReplacedText( text, query, newPart );
		
	} else if (mode == FIRST) {
		return SYSTEM_PROCESS_DRIVER_TEXT_replaceFirst( text, query, newPart);
	
	} else if (mode == FIRST_PATTERN) {
		return SYSTEM_PROCESS_DRIVER_TEXT_patternReplaceFirst( text, query, newPart);
		
	} else if (mode == LAST) {
		return SYSTEM_PROCESS_DRIVER_TEXT_replaceLast( text, query, newPart);
		
	} else if (mode == LAST_PATTERN) {
		return SYSTEM_PROCESS_DRIVER_TEXT_patternReplaceLast( text, query, newPart);
		
	} else {
		System.error(ERROR_UNKNOWN_MODE + toConstName(mode));
		return NULL;
	}
}

/**
 * テキストの指定位置以降から、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所を別の文字列で置き換えて返します。
 * 
 * @param text 対象のテキスト
 * @param searchBegin 検索開始位置の文字インデックス
 * @param newPart 検索一致箇所を置き換える文字列
 * @param searchBegin 検索開始位置
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所を置き換えた文字列
 */
public string replaceText( string text, string query, string newPart, int searchBegin, int mode ) {
	int textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
	string header = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, 0, searchBegin);
	string crop = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, searchBegin, textLength);
	string replaced = replaceText(crop, query, newPart, mode);
	string result = header + replaced;
	return result;
}

/**
 * テキストの指定範囲内から、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所を別の文字列で置き換えて返します。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param newPart 検索一致箇所を置き換える文字列
 * @param searchBegin 検索開始位置の文字インデックス
 * @param searchEnd 検索終了位置の文字インデックス + 1 （ <a href="#cropText">cropText</a> 参照 ）
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所を置き換えた文字列
 */
public string replaceText( string text, string query, string newPart, int searchBegin, int searchEnd, int mode ) {
	int textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
	string header = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, 0, searchBegin);
	string crop = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, searchBegin, searchEnd);
	string footer = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, searchEnd, textLength);
	string replaced = replaceText(crop, query, newPart, mode);
	string result = header + replaced + footer;
	return result;
}





/**
 * テキストから、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所で元のテキストを分割したものを、配列にまとめて返します。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所で分割したテキストの配列
 */
public string[] splitText( string text, string query, int mode ){
	
	if (mode == ALL) {
		
		return SYSTEM_PROCESS_DRIVER_TEXT_getSplittedWords( text, query );
		
	} else if (mode == ALL_PATTERN) {
		
		return SYSTEM_PROCESS_DRIVER_TEXT_getPatternSplittedWordsWithEnd( text, query );
		
	}
	
	int index = 0;
	int textLength = 0;
	int queryLength = 0;
	
	if (mode == FIRST) {
		
		index = SYSTEM_PROCESS_DRIVER_TEXT_getWordIndex(text, query);
		textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
		queryLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(query);
		
	} else if (mode == FIRST_PATTERN) {
		
		index = SYSTEM_PROCESS_DRIVER_TEXT_getPatternWordIndex(text, query);
		textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
		string matched = SYSTEM_PROCESS_DRIVER_TEXT_firstMatch(text, query);
		if (matched != NULL) {
			queryLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(matched);
		}
		
	} else if (mode == LAST) {
		
		index = SYSTEM_PROCESS_DRIVER_TEXT_getLastWordIndex(text, query);
		textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
		queryLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(query);
		
	} else if (mode == LAST_PATTERN) {
		
		index = SYSTEM_PROCESS_DRIVER_TEXT_getPatternLastWordIndex(text, query);
		textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
		string matched = SYSTEM_PROCESS_DRIVER_TEXT_lastMatch(text, query);
		if (matched != NULL) {
			queryLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(matched);
		}
		
	} else {
		
		System.error(ERROR_UNKNOWN_MODE + toConstName(mode));
		string result[0];
		return result;
	}
	
	if (index < 0) {
		
		string result[] = { text };
		return result;
		
	} else {
		
		string frontPart = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, 0, index);
		string rearPart = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, index + queryLength, textLength);
		string result[] = { frontPart, rearPart };
		return result;
		
	}
}

/**
 * テキストの指定位置以降から、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所で元のテキストを分割したものを、配列にまとめて返します。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param searchBegin 検索開始位置の文字インデックス
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所で分割したテキストの配列
 */
public string[] splitText( string text, string query, int searchBegin, int mode ) {
	int textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
	string header = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, 0, searchBegin);
	string crop = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, searchBegin, textLength);
	string split[] = splitText(crop, query, mode);
	int n = length(split);
	split[0] = header + split[0];
	return split;
}

/**
 * テキストの指定範囲内から、部分文字列（ または正規表現 ）に一致する箇所を検索し、一致箇所で元のテキストを分割したものを、配列にまとめて返します。
 * 
 * @param text 対象のテキスト
 * @param query 検索する部分文字列
 * @param searchBegin 検索開始位置の文字インデックス
 * @param searchEnd 検索終了位置の文字インデックス + 1 （ <a href="#cropText">cropText</a> 参照 ）
 * @param mode 検索モード（ <a href="#ALL">ALL</a>, <a href="#FIRST">FIRST</a>, <a href="#LAST">LAST</a>, <a href="#ALL_PATTERN">ALL_PATTERN</a>, <a href="#FIRST_PATTERN">FIRST_PATTERN</a>, <a href="#LAST_PATTERN">LAST_PATTERN</a> ）
 * @return 検索一致箇所で分割したテキストの配列
 */
public string[] splitText( string text, string query, int searchBegin, int searchEnd, int mode ) {
	int textLength = SYSTEM_PROCESS_DRIVER_TEXT_countTextLength(text);
	string header = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, 0, searchBegin);
	string crop = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, searchBegin, searchEnd);
	string footer = SYSTEM_PROCESS_DRIVER_TEXT_getSubtext(text, searchEnd, textLength);
	string split[] = splitText(crop, query, mode);
	int n = length(split);
	
	if (n == 1) {
		
		split[0] = header + split[0] + footer;
		return split;
		
	} else {
		
		split[0] = header + split[0];
		split[n-1] = split[n-1] + footer;
		return split;
		
	}
}












/**
 * 文字列を、特定の文字列の位置で分割し、配列にまとめて返します。
 * <br />
 * 現在は、同様の（またはより高度な）機能を提供する、新しい <a href="Text.html#splitText">splitText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#splitText">splitText</a>(text, query, <a href="Text.html#ALL">ALL</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 * <br />
 * なお、この関数では、引数 text のちょうど終端に query が存在する場合、その後に空文字があるとは見なされず、返される配列の最終要素にも空文字は格納されません。
 * この点の挙動は splitText と異なりますが、互換性を保つため、今後も改修されません。
 *
 * @param text 対象の文字列
 * @param query 分割点の文字列（結果の文字列配列の内容には含まれません）
 * @return 分割結果を格納する配列
 */
string[] split( string text, string query ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getSplittedWords( text, query );
}


/**
 * 文字列を、特定の正規表現に適合する位置で分割し、配列にまとめて返します。
 * <br />
 * 現在は、同様の（またはより高度な）機能を提供する、新しい <a href="Text.html#splitText">splitText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#splitText">splitText</a>(text, query, <a href="Text.html#ALL_PATTERN">ALL_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 * <br />
 * なお、この関数では、引数 text のちょうど終端に query が存在する場合、その後に空文字があるとは見なされず、返される配列の最終要素にも空文字は格納されません。
 * この点の挙動は splitText と異なりますが、互換性を保つため、今後も改修されません。
 *
 *
 * @param text 対象の文字列
 * @param query 分割点の正規表現（結果の文字列配列の内容には含まれません）
 * @return 分割結果を格納する配列
 */
string[] splitPattern( string text, string query ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getPatternSplittedWords( text, query );
}


/**
 * 文字列に含まれる部分文字列を、全て別の部分文字列に置換したものを返します。
 * <br />
 * 現在は、同様の（またはより高度な）機能を提供する、新しい <a href="Text.html#replaceText">replaceText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#replaceText">replaceText</a>(text, query, <a href="Text.html#ALL">ALL</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param oldText 置換前の部分文字列
 * @param newText 置換後の部分文字列
 * @return 置換結果
 */
string replace( string text, string oldText, string newText ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getReplacedText( text, oldText, newText );
}


/**
 * 文字列内で正規表現に適合する区間を、全て別の部分文字列に置換したものを返します。
 * <br />
 * 現在は、同様の（またはより高度な）機能を提供する、新しい <a href="Text.html#replaceText">replaceText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#replaceText">replaceText</a>(text, query, <a href="Text.html#ALL_PATTERN">ALL_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param oldText 置換箇所の正規表現
 * @param newText 置換後の部分文字列
 * @return 置換結果
 */
string replacePattern( string text, string oldText, string newText ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getPatternReplacedText( text, oldText, newText );
}


/**
 * 文字列に含まれる部分文字列を、最初のものだけ、別の部分文字列に置換したものを返します。
 * <br />
 * 現在は、同様の（またはより高度な）機能を提供する、新しい <a href="Text.html#replaceText">replaceText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#replaceText">replaceText</a>(text, query, <a href="Text.html#FIRST">FIRST</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param oldText 置換前の部分文字列
 * @param newText 置換後の部分文字列
 * @return 置換結果
 */
string replaceFirst( string text, string oldText, string newText ){
  return SYSTEM_PROCESS_DRIVER_TEXT_replaceFirst( text, oldText, newText, 0 );
}


/**
 * 文字列内で正規表現に適合する区間を、最初のものだけ、別の部分文字列に置換したものを返します。
 * <br />
 * 現在は、同様の（またはより高度な）機能を提供する、新しい <a href="Text.html#replaceText">replaceText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#replaceText">replaceText</a>(text, query, <a href="Text.html#FIRST_PATTERN">FIRST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param oldText 置換箇所の正規表現
 * @param newText 置換後の部分文字列
 * @return 置換結果
 */
string replaceFirstPattern( string text, string oldText, string newText ){
  return SYSTEM_PROCESS_DRIVER_TEXT_patternReplaceFirst( text, oldText, newText, 0 );
}



/**
 * 文字列に含まれる部分文字列を、別の部分文字列に置換したものを返します。
 * 部分文字列の適合箇所が複数存在する場合は、引数 start に指定したインデックス以降で、最初のものだけが置換されます。
 * <br />
 * 現在は、同様の（またはより高度な）機能を提供する、新しい <a href="Text.html#replaceText">replaceText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#replaceText">replaceText</a>(text, query, start, <a href="Text.html#FIRST">FIRST</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param oldText 置換前の部分文字列
 * @param newText 置換後の部分文字列
 * @param start 探索範囲の始点インデックス
 * @return 置換結果
 */
string replaceFirst( string text, string oldText, string newText, int start ){
  return SYSTEM_PROCESS_DRIVER_TEXT_replaceFirst( text, oldText, newText, start );
}


/**
 * 文字列内で正規表現に適合する区間を、別の部分文字列に置換したものを返します。
 * 正規表現の適合箇所が複数存在する場合は、引数 start に指定したインデックス以降で、最初のものだけが置換されます。
 * <br />
 * 現在は、同様の（またはより高度な）機能を提供する、新しい <a href="Text.html#replaceText">replaceText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#replaceText">replaceText</a>(text, query, start, <a href="Text.html#FIRST_PATTERN">FIRST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param oldText 置換箇所の正規表現
 * @param newText 置換後の部分文字列
 * @param start 探索範囲の始点インデックス
 * @return 置換結果
 */
string replaceFirstPattern( string text, string oldText, string newText, int start ){
  return SYSTEM_PROCESS_DRIVER_TEXT_patternReplaceFirst( text, oldText, newText, start );
}




/**
 * 文字列内の、指定されたインデックス区間にある部分文字列を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#cropText">cropText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#cropText">cropText</a>(text, start, end) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param start 区間の始点インデックス。
 * @param end 区間の終点インデックス + 1
 * @return 部分文字列
 */
string substring( string text, int start, int end ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getSubtext( text, start, end );
}


/**
 * 文字列の文字数を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#countText">countText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#countText">countText</a>(text) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @return 文字数
 */
int lengthOf( string text ){
  return SYSTEM_PROCESS_DRIVER_TEXT_countTextLength( text );
}


















/**
 * 文字列が、指定された部分文字列で始まっているかどうか判定します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#checkText">checkText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#checkText">checkText</a>(text, word, <a href="Text.html#START">START</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param word 部分文字列
 * @return 指定された部分文字列で始まっていれば true 、そうでなければ false 
 */
bool startsWith( string text, string word ){
  return SYSTEM_PROCESS_DRIVER_TEXT_startsWith( text, word );
}


/**
 * 文字列が、指定された部分文字列で終わっているかどうか判定します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#checkText">checkText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#checkText">checkText</a>(text, word, <a href="Text.html#END">END</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param word 部分文字列
 * @return 指定された部分文字列で終わっていれば true 、そうでなければ false 
 */
bool endsWith( string text, string word ){
  return SYSTEM_PROCESS_DRIVER_TEXT_endsWith( text, word );
}



/* match will be returns array value */

/**
 * この API の使用は推奨されません。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#extractText">extractText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#extractText">extractText</a>(text, pattern, <a href="Text.html#FIRST_PATTERN">FIRST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 */
string match( string text, string pattern ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getMatch( text, pattern );
}

/**
 * この API の使用は推奨されません。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#extractText">extractText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#extractText">extractText</a>(text, pattern, start, <a href="Text.html#FIRST_PATTERN">FIRST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 */
string match( string text, string pattern, int start ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getMatch( text, pattern, start );
}



/**
 * 文字列全体が、正規表現に適合するかどうか判定します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#checkText">checkText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#checkText">checkText</a>(text, word, <a href="Text.html#FULL_PATTERN">FULL_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param pattern 正規表現
 * @return 全体が正規表現に適合すれば true 、そうでなければ false 
 */
bool matchFull( string text, string pattern ){
  return SYSTEM_PROCESS_DRIVER_TEXT_totalMatch( text, pattern );
}


/**
 * 文字列全体から、正規表現に最初に適合する箇所を抜き出して返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#extractText">extractText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#extractText">extractText</a>(text, pattern, <a href="Text.html#FIRST_PATTERN">FIRST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param pattern 正規表現
 * @return 正規表現に適合する箇所の部分文字列
 */
string matchFirst( string text, string pattern ){
  return SYSTEM_PROCESS_DRIVER_TEXT_firstMatch( text, pattern );
}


/**
 * 文字列から、正規表現に適合する箇所を抜き出して返します。
 * 正規表現の適合箇所が複数存在する場合は、引数 start に指定したインデックス以降から、最初のものだけが選択されます。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#extractText">extractText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#extractText">extractText</a>(text, pattern, <a href="Text.html#FIRST_PATTERN">FIRST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param pattern 正規表現
 * @return 正規表現に適合する箇所の部分文字列
 * @param start 探索範囲の始点インデックス
 * @return 正規表現に適合する箇所の部分文字列
 */
string matchFirst( string text, string pattern, int start ){
  return SYSTEM_PROCESS_DRIVER_TEXT_firstMatch( text, pattern, start );
}


/**
 * 文字列全体から、正規表現に最後に適合する箇所を抜き出して返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#extractText">extractText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#extractText">extractText</a>(text, pattern, <a href="Text.html#LAST_PATTERN">LAST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param pattern 正規表現
 * @return 正規表現に適合する箇所の部分文字列
 */
string matchLast( string text, string pattern ){
  return SYSTEM_PROCESS_DRIVER_TEXT_lastMatch( text, pattern );
}


/**
 * 文字列から、正規表現に適合する箇所を抜き出して返します。
 * 正規表現の適合箇所が複数存在する場合は、引数 end に指定したインデックスの位置よりも前から、最後のものだけが選択されます。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#extractText">extractText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#extractText">extractText</a>(text, pattern, 0, end, <a href="Text.html#LAST_PATTERN">LAST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param pattern 正規表現
 * @param end 探索範囲の終点インデックス
 * @return 正規表現に適合する箇所の部分文字列
 */
string matchLast( string text, string pattern, int end ){
  return SYSTEM_PROCESS_DRIVER_TEXT_lastMatch( text, pattern, end );
}





/**
 * 文字列内から、指定された部分文字列の位置を取得します。
 * 複数存在する場合は、最初のものが選択されます。存在しない場合は -1 を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#findText">findText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#findText">findText</a>(text, word, <a href="Text.html#FIRST">FIRST</a>) とすればこの関数と同様の結果が得られます。
 * （ただし、一致部分が無い場合は要素数 0 の配列が返されます。）
 * <br />
 * 文字列内に部分文字列が含まれているかどうかの判断は、 0 &lt; <a href="Text.html#countText">countText</a>(text, word, <a href="Text.html#ALL">ALL</a>) などで行えます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param word 部分文字列
 * @return 部分文字列の位置インデックス
 */
int indexOf( string text, string word ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getWordIndex( text, word );
}


/**
 * 文字列内から、指定された部分文字列の位置を取得します。
 * 複数存在する場合は、引数 start に指定したインデックス以降から、最初のものが選択されます。存在しない場合は -1 を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#findText">findText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#findText">findText</a>(text, word, start, <a href="Text.html#FIRST">FIRST</a>) とすればこの関数と同様の結果が得られます。
 * （ただし、一致部分が無い場合は要素数 0 の配列が返されます。）
 * <br />
 * 文字列内の指定位置以降に部分文字列が含まれているかどうかの判断は、 0 &lt; <a href="Text.html#countText">countText</a>(text, word, start, <a href="Text.html#ALL">ALL</a>) などで行えます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param word 部分文字列
 * @param start 探索範囲の始点インデックス。
 * @return 部分文字列の位置インデックス
 */
int indexOf( string text, string word, int start ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getWordIndex( text, word, start );
}


/**
 * 文字列内から、指定された正規表現に適合する位置を取得します。
 * 複数存在する場合は、最初のものが選択されます。存在しない場合は -1 を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#findText">findText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#findText">findText</a>(text, word, <a href="Text.html#FIRST_PATTERN">FIRST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * （ただし、一致部分が無い場合は要素数 0 の配列が返されます。）
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param word 正規表現
 * @return 適合箇所の位置インデックス
 */
string indexOfPattern( string text, string word ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getPatternWordIndex( text, word );
}


/**
 * 文字列内から、指定された正規表現に適合する位置を取得します。
 * 複数存在する場合は、最初のものが選択されます。引数 start に指定したインデックス以降から、存在しない場合は -1 を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#findText">findText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#findText">findText</a>(text, word, start, <a href="Text.html#FIRST_PATTERN">FIRST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * （ただし、一致部分が無い場合は要素数 0 の配列が返されます。）
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param word 正規表現
 * @param start 探索範囲の終点インデックス。
 * @return 適合箇所の位置インデックス
 */
string indexOfPattern( string text, string word, int start ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getPatternWordIndex( text, word, start );
}


/**
 * 文字列内から、指定された部分文字列の位置を取得します。
 * 複数存在する場合は、最後のものが選択されます。存在しない場合は -1 を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#findText">findText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#findText">findText</a>(text, word, <a href="Text.html#LAST">LAST</a>) とすればこの関数と同様の結果が得られます。
 * （ただし、一致部分が無い場合は要素数 0 の配列が返されます。）
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param word 部分文字列
 * @return 部分文字列の位置インデックス
 */
int lastIndexOf( string text, string word ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getLastWordIndex( text, word );
}



/**
 * 文字列内から、指定された部分文字列の位置を取得します。
 * 複数存在する場合は、引数 end に指定したインデックス以前から、最後のものが選択されます。存在しない場合は -1 を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#findText">findText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#findText">findText</a>(text, word, 0, end, <a href="Text.html#LAST">LAST</a>) とすればこの関数と同様の結果が得られます。
 * （ただし、一致部分が無い場合は要素数 0 の配列が返されます。）
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param word 部分文字列
 * @param end 探索範囲の終点インデックス。
 * @return 部分文字列の位置インデックス
 */
int lastIndexOf( string text, string word, int end ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getLastWordIndex( text, word, end );
}


/**
 * 文字列内から、指定された正規表現に適合する位置を取得します。
 * 複数存在する場合は、最後のものが選択されます。存在しない場合は -1 を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#findText">findText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#findText">findText</a>(text, word, <a href="Text.html#LAST_PATTERN">LAST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * （ただし、一致部分が無い場合は要素数 0 の配列が返されます。）
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param word 正規表現
 * @return 部分文字列の位置インデックス
 */
string lastIndexOfPattern( string text, string word ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getPatternLastWordIndex( text, word );
}


/**
 * 文字列内から、指定された正規表現に適合する位置を取得します。
 * 複数存在する場合は、引数 end に指定したインデックス以前から、最後のものが選択されます。存在しない場合は -1 を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#findText">findText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#findText">findText</a>(text, word, 0, end, <a href="Text.html#LAST_PATTERN">LAST_PATTERN</a>) とすればこの関数と同様の結果が得られます。
 * （ただし、一致部分が無い場合は要素数 0 の配列が返されます。）
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param word 正規表現
 * @param end 探索範囲の終点インデックス。
 * @return 部分文字列の位置インデックス
 */
string lastIndexOfPattern( string text, string word, int end ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getPatternLastWordIndex( text, word, end );
}








/**
 * 文字列内の、指定されたインデックスの位置にある文字を返します。
 * <br />
 * 現在は、同様の機能を提供する、新しい <a href="Text.html#atText">atText</a> 関数がサポートされています。
 * 例えば、<a href="Text.html#atText">atText</a>(text, index) とすればこの関数と同様の結果が得られます。
 * <br />
 * <span style="font-weight:bold;">この関数は互換目的でサポートされています。</span>
 *
 * @param text 対象の文字列
 * @param index 文字の位置インデックス
 * @return 文字
 */
string charAt( string text, int index ){
  return SYSTEM_PROCESS_DRIVER_TEXT_getCharacter( text, index );
}


// 未正式サポート
string replaceLineFeed( string text ){
  return SYSTEM_PROCESS_DRIVER_TEXT_replaceLineFeed( text );
}

/**
 * 文字列内を、空白またはタブ、もしくは改行区切りでトークンに分割し、配列にまとめて返します。
 *
 * @param text 対象の文字列
 * @return トークン配列
 */
string[] tokenize( string text ){
  return SYSTEM_PROCESS_DRIVER_TEXT_tokenize( text );
}



